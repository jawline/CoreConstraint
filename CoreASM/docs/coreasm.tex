\documentclass{article}

\title{CoreASM Documentation \\ \large Documentation on the CoreASM compiler}
\author{Blake Loring}
\date{\today}

\usepackage[parfill]{parskip}

\begin{document}
\maketitle

\section* {Instruction}

In order to make building code for the CoreVM virtual machine easier a simple assembler was constructed.

Similarly to the VirtualMachine CoreASM supports an integer only syntax and instructions (no floats).

The assembler itself uses a LL(1) grammar and subsequently has a very simple parser which is able to generate machine code for CoreVM in a single pass. 

\section* {Syntax}

The syntax of the assembly language is very simple, supporting only labels, data declarations and instructions.

Instructions follow the general pattern INSTRUCTION DEST OtherOperands, when applicable. With the conditional jump instructions
such as JEQ and JNE they follow the pattern INSTRUCTION Register Operand (Register or value) DESTINATION.

The data instructions can be used to allocate space in the binary which can be used to store data at runtime using the GET and SET instructions.
For example, the code
\begin {verbatim}
load A 5
set A variable
variable:
db 4
exit:
\end{verbatim}
sets the value of the memory allocated at label variable to 5. This can then be loaded into registers later using the GET instructions.

\section* {Usage}

The compiler only supports single files, and execution on the generated objects will begin from the first line of the file.

To compile an assembly file into CoreVM machine code the command coreasm INPUTFILE OUTPUTFILE should be invoked.

\section* {Implementation}
\section* {Examples}
\section* {Grammar}

TODO: Instruction Specifics (When Finalized).

\begin{verbatim}
NUM: [0-9]+
ID: [a-zA-Z][a-zA-Z0-9]*

Program: Block [Program]
Block: Label | Instruction | Data
Label: ID ':'
Data: 'db' NUM
Instruction:
	Add | Sub | Mul | Div | Load | Move | Set | Get | JumpEqual | JumpNotEqual | Interrupt
\end{verbatim}
\end{document}
